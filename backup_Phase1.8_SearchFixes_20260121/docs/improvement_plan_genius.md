# MEKIKI Proofing System 改善計画書 (Genius Edition Roadmap)

ユーザーの要望に基づき、現在のシステムログとコードベース (`advanced_comparison_view.py` は約2800行に達する巨大クラス) を分析し、本質的な課題と解決策を定義します。

---

## 1. 思考の連鎖 (Chain of Thought)

### 前提整理
- **現状:** `AdvancedComparisonView` は、Web OCR結果とPDF OCR結果を比較し、シンクロ率(Sync Rate)と視覚的な差異を表示するシステムである。
- **問題点:**
  - 巨大なモノリシックなクラス (`AdvancedComparisonView`) にロジックが集中しており、保守性が限界に近い。
  - 「自動Sync」と「高度マッチ」で処理フローが乖離しており、ユーザーに混乱を与えた (例: 高度マッチボタンで精度が落ちる現象)。
  - UIの更新がデータモデルの更新と同期しておらず、手動パッチ (`_recalculate_sync` vs `_run_advanced_cluster_matching`) が散在している。

### 論理構築
1. **データの信頼性:** `SyncPair` や `EditableRegion` などのデータモデルが、メソッド間で一貫して扱われていない。特に `SyncPair` が単なるデータ保持クラスでなく、ロジックの結果としてアドホックに生成されている点が脆弱性の原因。
2. **アルゴリズムの統合:** `ParagraphMatcher` (テキストベース) と `CrossDocumentAligner` (構造ベース) が競合している。本来は「構造で大枠を捉え、テキストで詳細を詰める」というハイブリッドなパイプライン一本に統合すべきである。
3. **UXの直感性:** ユーザーは「ボタンを押せば良くなる」ことを期待する。内部ロジックの違いをユーザーに意識させてはならない。

### 結論
**「統合されたデータパイプラインに基づく、単一の信頼できる情報源 (Single Source of Truth) の構築」** が必要である。
具体的には、全ての表示（Canvas, Spreadsheet, SyncRate）が、単一の `MatchResult` オブジェクトから生成されるアーキテクチャへ移行する。

---

## 2. 自己批判による修正ループ

### 初案
- クラスを分割してリファクタリングする。
- `AdvancedMatch` ロジックを削除し、`AutoSync` に一本化する。

### 批判的思考 (Critique)
1. **不十分点:** クラス分割だけでは、データの整合性は保証されない。データフロー（State Management）の設計が必要。
2. **論理の穴:** `AutoSync` だけでは、レイアウトが複雑な帳票などで対応できない可能性がある。`ClusterMatcher` の強力な幾何学的マッチング能力は維持すべき。
3. **リスク:** リファクタリング中に機能停止するリスクが高い。

### 改善版回答
- **State Management:** `ComparisonState` クラスを導入し、Web/PDFの領域とマッチング状態を一元管理する。
- **Hybrid Pipeline:** `AutoSync` の中に「幾何学的補正」フェーズとして旧 `ClusterMatcher` のロジックを組み込む（完全削除ではなく統合）。
- **Incremental Refactor:** 既存の `advanced_comparison_view.py` を動かしながら、内部ロジックを徐々に新モジュールへ委譲する。

---

## 3. 抽象化と具体化の往復

### 本質的な課題 (抽象化)
**「多角的整合性の欠如 (Lack of Multimodal Consistency)」**
- テキスト情報、位置情報、視覚情報がバラバラに処理され、最終的な「正解」がどれか分からない状態。

### 具体的な解決策 (行動レベル)
1. **データ構造の定義:** `Region` オブジェクトに `text`, `rect`, `visual_feature`, `match_id` を全て持たせ、不変(Immutable)なIDで管理する。
2. **パイプラインの統一:** 
   - 入力: Web画像/テキスト + PDF画像/テキスト
   - 処理: `Pre-processing` -> `Layout Analysis` -> `Anchor Matching` -> `Text Refinement`
   - 出力: `UnifiedMatchResult`
3. **UIの受動化:** UIは `UnifiedMatchResult` を描画するだけの「ビュー」に徹する（ロジックを持たない）。

---

## 4. 多視点からの検証と統合

- **肯定派 (機能重視):** 「今の `AnchorMatcher` は速くて正確だ。これをベースに拡張すべき。」
- **否定派 (構造重視):** 「コードがスパゲッティだ。一度捨てて作り直さないと、次はバグの温床になる。」
- **中立派 (UX重視):** 「ユーザーにとっては内部はどうでもいい。スプレッドシートが見やすく、精度が高ければいい。」

### 統合された結論
**「機能（AnchorMatcher）を核に、構造（リファクタリング）を整え、UX（スプレッドシート）を磨く」**
- 完全な書き直しは避け（コスト大）、`AnchorMatcher` をコアエンジンとして正式採用する。
- `advanced_comparison_view.py` 内のロジック部分を `core/engine` に切り出す「外科手術」を行う。

---

## 5. なぜ？を繰り返す深掘り

1. **なぜシンクロ率が低下した？** -> 劣ったアルゴリズムが優れた結果を上書きしたから。
2. **なぜ上書きできた？** -> 処理が独立しており、前の結果を参照せずに新規計算したから。
3. **なぜ独立している？** -> 機能追加のたびにメソッドを追加し、全体のパイプラインとして設計されていないから。
4. **なぜ設計されていない？** -> 「とりあえず動くもの」を積み重ねたアジャイル的な開発の弊害（技術的負債）。
5. **根本原因は？** -> **「システム全体のデータフロー図（青写真）」が存在しないまま拡張を続けたこと。**

### 根本解決策
**「システムアーキテクチャ図の策定と、それに従ったモジュール再配置」**
コードを書く前に、データがどこで生まれ、どこで加工され、どこで表示されるかのフローを確定させる。

---

## 6. 思考の解像度を段階的に上げる

### Level 1: 小学生レベル
「文章の形（レイアウト）と中身（テキスト）の両方を見て、一番似ているところを線で結ぶ『名探偵ソフト』にします。迷ったら、確実なヒント（アンカー）を頼りに推測します。」

### Level 2: 専門家レベル
「『Isomorphic Graph Matching（同型グラフマッチング）』アプローチを採用します。WebとPDFをそれぞれノード（領域）とエッジ（相対位置）のグラフとして表現し、テキスト類似度を重みとしてグラフ間の最大共通部分グラフを探索します。計算量は `AnchorMatcher` による探索空間の枝刈りで $O(N \log N)$ に抑えます。」

### Level 3: 実務的な注意点
「既存の `sync_pairs` リストは `tuple` ではなく `dataclass` 化し、`web_id`, `pdf_id` だけでなく `text_preview` や `diff_html` もキャッシュしてください。スプレッドシート描画時の $O(N)$ テキストルックアップを回避し、スクロールを滑らかにするためです。」

---

## 7. 反証による仮説テスト

### 仮説
「`AnchorMatcher` に統一すれば万事解決する。」

### 反証 (データ探索)
- 画像のみのページや、テキストが極端に少ないページでは、アンカー（特徴的なテキスト）が見つからず、マッチング不能になる恐れがある。
- 完全にレイアウトが崩れている（リフローされた）Webページでは、位置情報はノイズになり、テキストのみのマッチング (`TF-IDF` 等) の方が精度が良い場合がある。

### 確度の高い事実
- **「ハイブリッド戦略が必要」**: 
  - 位置情報が有効な場合 -> Anchor Alignment
  - 位置情報が無効な場合 -> Bag-of-Words Matching
  この分岐判定（Strategy Selector）を実装することが、堅牢性の鍵である。

---

## 8. シナリオ分岐シミュレーション

- **Best Case:** リファクタリングによりコード量が半減し、新機能（AI校正など）がプラグイン感覚で追加できるようになる。Sync率は常に80%超え。
- **Worst Case:** リファクタリング中にデグレード（機能退行）が発生し、現在の「なんとか動いている状態」すら失う。
- **Most Likely:** スプレッドシートとSyncロジックは安定するが、特殊なPDF（表組など）での精度課題は残り、個別チューニングが必要になる。

### 勝敗の分かれ目
**「テストケース（Golden Sample）の確保」**
リファクタリング前後で、現在の「成功している画像ペア」の結果が変わらないことを保証する自動テストを用意できるかどうかが鍵。

---

## 10. 最終チェックリスト

- [x] **論理的整合性:** 課題（データ不整合）と解決策（パイプライン統一）がリンクしているか。 -> OK
- [x] **事実確認:** ユーザーの直面したエラー（`AttributeError`, シンクロ率低下）を解決済みか。 -> OK (今回の修正で実証済み)
- [x] **過不足:** 将来の拡張性（AI機能）まで考慮されているか。 -> OK (`UnifiedMatchResult` はAI入力に適している)

---

# 改善提案: Project "MEKIKI Genius"

## Phase 1: Stabilization (完了目前)
- [x] 表示系バグの修正 (Spreadsheet Grid, Sync Rate)
- [x] ロジックの暫定統一 (`_run_advanced` -> `_auto_sync`)
- [ ] エラーハンドリングの強化（例外発生時もアプリを落とさない）

## Phase 2: Refactoring (推奨)
1. **Model層の分離:** `comparison_model.py` を作成し、`WebRegions`, `PdfRegions`, `SyncPairs` を管理。
2. **Logic層の分離:** `AdvancedComparisonView` から `_calculate_...` 系メソッドを全て `core/engine/matching_engine.py` へ移動。
3. **View層の軽量化:** `AdvancedComparisonView` はユーザー操作の受付と描画のみに専念。

## Phase 3: Intelligent Evolution (未来)
- **AI Semantic Check:** 単なる文字一致でなく、「意味的に同じか」をLLMで判定。
- **Auto-Correction:** PDFの誤植箇所をAIが推測し、修正案を提示。

**今すぐやるべきこと:**
まずは Phase 1 の状態（現在の Gemni3_backup）を安定板として運用し、裏で Phase 2 の設計を開始することを提案します。
